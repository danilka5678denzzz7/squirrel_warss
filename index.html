<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Squirrel Wars - Prototyp v7.3 (Bot Text Fix)</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Обнуление и базовые стили */
        body, html {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
            overflow: hidden; 
        }

        #root {
            height: 100vh;
        }

        /* Контейнер всей игры */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 500px; 
            margin: 0 auto;
            background-color: #222;
            background-image: url('images/bg_forest_main.png');
            background-size: cover;
            background-position: center;
        }

        /* 1. Хедер (Шапка) */
        .header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: none; 
            border-bottom: none; 
            flex-shrink: 0;
        }
        
        .header-user {
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 1.1em;
            background: rgba(0, 0, 0, 0.6); 
            padding: 8px 18px; 
            border-radius: 25px; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); 
            gap: 8px;
        }
        .header-user img {
            width: 40px; 
            height: 40px;
            border-radius: 50%;
            border: 2px solid gold; 
            flex-shrink: 0;
        }
        
        .header-balance {
            font-size: 1.4em; 
            font-weight: bold;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.6); 
            padding: 8px 18px; 
            border-radius: 25px; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); 
            gap: 8px; 
        }
        .header-balance img {
            width: 40px; 
            height: 40px;
            object-fit: contain; 
            border-radius: 50%; 
            border: 2px solid rgba(255, 215, 0, 0.7); 
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.5); 
            flex-shrink: 0; 
        }

        /* 2. Игровой экран (меняется) */
        .game-screen {
            flex-grow: 1;
            padding: 0; 
            overflow: hidden; 
            position: relative; 
        }
        
        .boost-header {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px 0;
            background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.2));
            border-radius: 10px;
            border-bottom: 3px solid gold;
        }
        .boost-header h2 {
            margin: 0;
            font-size: 1.8em;
            color: gold;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.8), 0 0 10px rgba(255, 215, 0, 0.5);
            font-weight: 900;
            letter-spacing: 1px;
        }

        .golden-nut-container {
            position: absolute;
            width: 75px; 
            height: 75px;
            cursor: pointer;
            z-index: 50;
            filter: drop-shadow(0 0 8px gold);
            transition: top 1s ease-in-out, left 1s ease-in-out, opacity 0.3s; 
        }
        .golden-nut-container img {
            width: 100%;
            height: 100%;
            animation: floatBob 1.5s infinite alternate ease-in-out;
        }
        
        @keyframes floatBob {
            0% { transform: translateY(0) rotate(0deg); }
            100% { transform: translateY(-5px) rotate(2deg); }
        }
        
        /* ИСПРАВЛЕНИЕ: Активный бонус теперь всегда в одну строку */
        .active-bonus-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex; 
            justify-content: center;
            align-items: center; 
            
            padding: 8px 15px; /* Увеличил вертикальный паддинг */
            background: rgba(255, 215, 0, 0.9);
            color: black;
            font-weight: 900; 
            
            border-radius: 5px;
            z-index: 60;
            animation: flash 0.5s infinite alternate;
            
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            white-space: nowrap; /* Гарантируем одну строку */
        }
        
        /* Убираем ненужные стили, которые создавали столбец */
        .bonus-indicator-item {
            display: inline-block; /* Теперь это одна строка */
            text-align: center; 
            margin: 0; 
            font-size: 1.1em;
        }
        
        .bonus-indicator-item span {
             font-weight: 900; 
             margin-right: 5px; /* Небольшой отступ после значка ⚡️ */
        }
        
        .bonus-indicator-subtext {
            font-size: 0.9em; /* Чуть меньше основной строки */
            font-weight: 900; /* Жирный текст */
        }
        
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.8; }
        }
        
        .locked-screen-message {
            display: flex;
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            height: 100%;
            width: 100%;
            background: rgba(0, 0, 0, 0.9); 
            color: #FFD700; 
            font-size: 1.3em;
            font-weight: bold;
            padding: 20px;
            box-sizing: border-box; 
        }
        .locked-screen-message h3 {
             text-align: center; 
        }
        .locked-screen-message p {
            color: #eee; 
            font-size: 1em; 
            margin-top: 15px; 
            text-align: center; 
            max-width: 90%; 
        }


        .forest-content {
            position: relative;
            display: flex;
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            height: 100%;
            
            /* --- КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Включаем Мультитач --- */
            touch-action: manipulation; 
            /* -------------------------------------------------- */
        }

        .forest-screen .squirrel-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            transition: transform 0.05s ease;
            position: relative;
            z-index: 10;
            /* --- ИСПРАВЛЕНИЕ: Убираем синюю обводку при фокусе/клике --- */
            outline: none; 
            -webkit-tap-highlight-color: transparent; 
            user-select: none;
            /* ----------------------------------------------------- */
        }
        
        @keyframes clickShake {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        .forest-screen .squirrel-btn:active {
            animation: clickShake 0.15s ease-out; 
            transform: scale(0.98); 
        }

        .forest-screen .squirrel-btn img {
            width: 100%; 
            max-width: 400px; 
            height: auto; 
            position: relative;
            top: 20px; 
            pointer-events: none;
        }
        
        .forest-screen h3 {
            display: none; 
        }

        .tap-animation {
            position: absolute;
            top: 50%; 
            left: 50%;
            font-size: 2em;
            font-weight: 900;
            color: gold;
            text-shadow: 1px 1px 3px black;
            pointer-events: none;
            opacity: 0;
            animation: floatUp 1s ease-out forwards;
            z-index: 20;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translate(-50%, 0); }
            15% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -150px); }
        }
        
        @keyframes floatUpCrit {
            0% { opacity: 0; transform: translate(-50%, 0) scale(1); }
            15% { opacity: 1; transform: translate(-52%, -5px) scale(1.2) rotate(-5deg); }
            30% { opacity: 1; transform: translate(-48%, -10px) scale(1.2) rotate(5deg); }
            100% { opacity: 0; transform: translate(-50%, -150px) scale(1.2) rotate(0deg); }
        }
        
        .tap-animation.critical {
            font-size: 3em; 
            color: #FFA500; 
            text-shadow: 0 0 5px black, 0 0 10px #FFD700;
            animation: floatUpCrit 1s ease-out forwards; 
        }


        .game-screen-scroll {
             padding: 20px;
             overflow-y: auto;
             height: 100%;
        }
        .upgrade-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 50px;
        }
        .upgrade-item {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .upgrade-item img {
            width: 48px;
            height: 48px;
            margin-right: 15px;
            background: #444; 
            border-radius: 8px;
        }
        
        .upgrade-info {
            flex-grow: 1;
            text-align: left;
        }
        .upgrade-info strong {
            margin-bottom: 4px; 
            display: inline-block;
        }
        .upgrade-info .level-text {
            font-size: 0.9em;
            color: #aaa; 
            margin-bottom: 4px; 
        }
        .upgrade-info .description-line {
            font-size: 0.9em;
            color: #eee; 
            font-weight: 500;
            line-height: 1.3;
        }
        .upgrade-info .description-line-next {
            color: #4CAF50; 
            font-weight: bold;
        }
        
        .buy-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            flex-shrink: 0;
            transition: background-color 0.3s;
        }
        .buy-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
            animation: none; 
        }
        .buy-btn.purchased { 
            background-color: #3F51B5; 
        }
        .buy-btn.max-level {
            background-color: #CC0000;
            cursor: not-allowed;
        }
        
        .raid-content { display: flex; flex-direction: column; align-items: center; text-align: center; padding-top: 20px; }
        .raid-btn { background-color: #E53935; color: white; border: none; padding: 20px 30px; border-radius: 12px; font-size: 1.2em; font-weight: bold; cursor: pointer; margin-top: 20px; }
        .raid-log { margin-top: 30px; text-align: left; font-size: 0.9em; color: #ccc; width: 100%; padding: 0 20px; box-sizing: border-box; }
        .raid-battle-container { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; box-sizing: border-box; }
        .defender-info { margin-bottom: 20px; }
        .raid-hp-bar { width: 100%; max-width: 300px; height: 20px; background-color: rgba(255, 255, 255, 0.2); border-radius: 10px; overflow: hidden; margin-bottom: 10px; }
        .raid-hp-fill { height: 100%; background: linear-gradient(90deg, #E53935, #FFB300); transition: width 0.1s linear; }
        .raid-duplo-btn { background: none; border: none; padding: 0; cursor: pointer; transition: transform 0.05s ease; }
        .raid-duplo-btn img { width: 200px; height: auto; }
        .raid-result { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 30px; background: rgba(0, 0, 0, 0.8); border-radius: 15px; z-index: 100; text-align: center; }
        .energy-bar-container { padding: 10px 15px; flex-shrink: 0; background: rgba(0, 0, 0, 0.3); }
        .energy-bar-label { display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 5px; }
        .energy-bar-fill { width: 100%; height: 10px; background-color: rgba(255, 255, 255, 0.2); border-radius: 5px; overflow: hidden; }
        .energy-bar-inner { height: 100%; background: linear-gradient(90deg, #64DD17, #33B760); border-radius: 5px; transition: width 0.5s ease; }
        .tab-bar { display: flex; justify-content: space-around; background: rgba(0, 0, 0, 0.9); border-top: 1px solid rgba(255, 255, 255, 0.1); flex-shrink: 0; padding: 0 0 5px 0; }
        .tab-item { flex-grow: 1; padding: 5px 0 5px 0; text-align: center; cursor: pointer; color: #eee; border-top: 3px solid transparent; transition: color 0.2s, border-color 0.2s, transform 0.1s; font-size: 1em; font-weight: 500; }
        .tab-item:active { transform: scale(0.98); }
        .tab-item img { width: 32px; height: 32px; opacity: 0.9; margin-bottom: 2px; display: block; margin: 0 auto 2px auto; }
        .tab-item.active { color: #eee; border-top-color: #FFD700; }
        .tab-item.active img { opacity: 1; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .app-modal { background: #282828; padding: 30px; border-radius: 15px; max-width: 300px; width: 90%; text-align: center; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); border: 2px solid gold; animation: fadeIn 0.3s ease-out; box-sizing: border-box; }
        .app-modal h3 { font-size: 1.5em; margin-top: 0; margin-bottom: 15px; font-weight: bold; }
        .app-modal h3.success { color: #4CAF50; }
        .app-modal h3.max-level { color: #FFD700; text-shadow: 0 0 5px rgba(255, 215, 0, 0.8); }
        .app-modal h3.ended { color: #FF7043; }
        .app-modal p { color: white; font-size: 1.1em; margin-bottom: 20px; line-height: 1.4; }
        .app-modal .icon { font-size: 3em; margin-bottom: 15px; display: inline-block; }
        .app-modal .bot-icon { animation: pulse 1.5s infinite alternate; }
        .app-modal .level-icon { color: gold; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); }
        .app-modal .buy-btn { background-color: #4CAF50; color: white; font-weight: bold; padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; transition: background-color 0.2s; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); } 70% { box-shadow: 0 0 10px 10px rgba(76, 175, 80, 0); } 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); } }
        
        /* СТИЛИ ДЛЯ КНОПОК НА ОСНОВЕ ИЗОБРАЖЕНИЯ (Task, Daily) */
        .tasks-button, .daily-rewards-button { 
            position: absolute; 
            width: 65px; /* Размер 65px */
            height: 65px; /* Размер 65px */
            background: none; border: none; border-radius: 0; 
            display: flex; 
            justify-content: center; align-items: center; 
            cursor: pointer; z-index: 40; 
            padding: 0; 
            color: transparent; 
            text-shadow: none; 
        }
        
        /* СТИЛЬ ТОЛЬКО ДЛЯ КНОПКИ НАСТРОЕК (Уменьшенный размер) */
        .settings-button { 
            position: absolute; 
            width: 55px; /* УМЕНЬШЕНО для Settings */
            height: 55px; /* УМЕНЬШЕНО для Settings */
            background: none; border: none; border-radius: 0; 
            display: flex; 
            justify-content: center; align-items: center; 
            cursor: pointer; z-index: 40; 
            padding: 0; 
            color: transparent; 
            text-shadow: none; 
        }

        .tasks-button { top: 20px; right: 20px; }
        .daily-rewards-button { top: 95px; right: 20px; }
        .settings-button { top: 20px; left: 20px; right: auto; }

        .tasks-button img, .daily-rewards-button img, .settings-button img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.2s;
        }

        .settings-button:active img, .daily-rewards-button:active img, .tasks-button:active img { 
            transform: scale(0.95); 
        }
         
        .notification-badge { position: absolute; top: 0px; right: 0px; background: red; color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 0.6em; font-weight: bold; }
        .daily-rewards-button .notification-badge { top: 5px; right: 5px; }
        .tasks-modal { background: #282828; padding: 15px 20px 20px 20px; border-radius: 15px; max-width: 400px; width: 90%; text-align: center; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); border: 2px solid gold; animation: fadeIn 0.3s ease-out; box-sizing: border-box; max-height: 70vh; }
        .tasks-modal h2 { color: gold; margin-top: 0; display: flex; justify-content: center; align-items: center; position: relative; margin-bottom: 15px; }
        .task-tab-bar { display: flex; justify-content: space-around; border-bottom: 1px solid #555; margin-bottom: 15px; }
        .task-tab { flex-grow: 1; padding: 10px 5px; cursor: pointer; color: #aaa; font-weight: 500; border-bottom: 3px solid transparent; transition: color 0.2s, border-color 0.2s; position: relative; }
        .task-tab:hover { color: #eee; }
        .task-tab.active { color: gold; border-bottom-color: gold; }
        .task-tab-badge { position: absolute; top: 5px; right: 5px; background: red; color: white; width: 18px; height: 18px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 0.7em; font-weight: bold; line-height: 18px; }
        .task-list-content { max-height: calc(70vh - 150px); overflow-y: auto; &::-webkit-scrollbar { width: 6px; } &::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; } &::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); } }
        .task-item { display: flex; align-items: center; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 10px; margin-bottom: 10px; border: 1px solid rgba(255, 255, 255, 0.1); transition: background 0.3s, border-color 0.3s; }
        .task-item.is-claimable { background: rgba(76, 175, 80, 0.15); border-color: #4CAF50; }
        .task-item.is-claimable .buy-btn { background-color: #4CAF50; animation: pulse-green 1.5s infinite; }
        .task-item .icon { font-size: 2em; margin-right: 15px; }
        .task-info { flex-grow: 1; text-align: left; }
        .task-title-row { display: flex; align-items: center; gap: 8px; }
        .task-info-btn { background: #555; color: white; border: 1px solid #777; border-radius: 50%; width: 20px; height: 20px; font-size: 0.8em; font-weight: bold; padding: 0; cursor: pointer; line-height: 18px; flex-shrink: 0; }
        .task-info strong { font-size: 1.1em; }
        .task-info .progress-text { font-size: 0.9em; color: #aaa; }
        .progress-bar { width: 100%; height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 5px; overflow: hidden; }
        .progress-bar-inner { height: 100%; background: #4CAF50; border-radius: 4px; transition: width 0.3s; }
        .daily-rewards-modal { background: #282828; padding: 20px; border-radius: 15px; max-width: 400px; width: 90%; text-align: center; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); border: 2px solid gold; animation: fadeIn 0.3s ease-out; box-sizing: border-box; max-height: 90vh; overflow-y: auto; }
         .daily-rewards-modal h2 { color: gold; margin-top: 0; margin-bottom: 20px; }
        .daily-rewards-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        .daily-reward-item { background: rgba(0, 0, 0, 0.3); border: 2px solid #555; border-radius: 10px; padding: 15px 10px; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100px; box-sizing: border-box; }
        .daily-reward-item .day-label { font-size: 0.9em; font-weight: bold; color: #aaa; margin-bottom: 10px; }
        .daily-reward-item .reward-icon { font-size: 2em; margin-bottom: 10px; }
        .daily-reward-item .reward-label { font-size: 1em; font-weight: bold; }
        .daily-reward-item.day-7 { grid-column: span 3; background: linear-gradient(145deg, rgba(0, 0, 0, 0.3), rgba(255, 215, 0, 0.1)); border-color: #777; }
        .daily-reward-item.locked { background: rgba(0, 0, 0, 0.6); border-color: #444; color: #777; cursor: pointer; }
         .daily-reward-item.locked .reward-icon { font-size: 2.5em; }
        .daily-reward-item.claimed { background: rgba(0, 0, 0, 0.1); border-color: #4CAF50; opacity: 0.6; }
        .daily-reward-item.claimed .reward-icon { font-size: 2.5em; color: #4CAF50; }
        .daily-reward-item.available { background: rgba(76, 175, 80, 0.15); border-color: #4CAF50; color: #fff; cursor: pointer; animation: pulse-green 1.5s infinite; transition: transform 0.2s ease; }
        .daily-reward-item.available:hover { transform: scale(1.05); }
        .settings-modal { background: #282828; padding: 20px; border-radius: 15px; max-width: 400px; width: 90%; text-align: left; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); border: 2px solid gold; animation: fadeIn 0.3s ease-out; box-sizing: border-box; max-height: 90vh; overflow-y: auto; }
        .settings-modal h2 { color: gold; margin-top: 0; margin-bottom: 25px; text-align: center; }
        .settings-section { margin-bottom: 20px; }
        .settings-section h3 { margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .settings-section p { font-size: 0.95em; color: #ccc; line-height: 1.5; margin: 0; }
        .settings-toggle-row { display: flex; justify-content: space-between; align-items: center; font-size: 1.1em; font-weight: bold; padding: 10px 0; }
        .settings-toggle-row input[type="range"] { flex-grow: 1; margin-left: 15px; margin-right: 10px; cursor: pointer; }
        .settings-toggle-row span { min-width: 45px; text-align: right; font-variant-numeric: tabular-nums; }
        .settings-button-link { display: block; background-color: #007BFF; color: white !important; text-decoration: none; padding: 12px 15px; border-radius: 8px; font-weight: bold; cursor: pointer; text-align: center; transition: background-color 0.2s; margin-top: 10px; border: none; width: 100%; box-sizing: border-box; font-size: 1em; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .settings-button-link:hover { background-color: #0056b3; }

    </style>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        
        const { useState, useEffect, useRef } = React;

        let tapIdCounter = 0;
        
        // =================================================================
        // ФАЛЬШИВАЯ БАЗА ДАННЫХ И КОНСТАНТЫ
        // =================================================================
        
        const DAILY_REWARDS_CATALOG = [
            { day: 1, type: 'nut', value: 1000, icon: '💰', label: '1 000 $NUT' },
            { day: 2, type: 'nut', value: 5000, icon: '💰', label: '5 000 $NUT' },
            { day: 3, type: 'bonus', bonus: { type: 'madness', name: 'Безумие', multiplier: 10, duration: 10 }, icon: '⚡', label: 'x10 Клик (10с)' },
            { day: 4, type: 'nut', value: 25000, icon: '💰', label: '25 000 $NUT' },
            { day: 5, type: 'bonus', bonus: { type: 'speed', name: 'Ускорение', rate: 15, duration: 15 }, icon: '⚡', label: '+15 ⚡️/сек (15с)' },
            { day: 6, type: 'nut', value: 50000, icon: '💰', label: '50 000 $NUT' },
            { day: 7, type: 'nut', value: 100000, icon: '🎉', label: '100 000 $NUT' },
        ];
        
        const SAVE_DATA_KEY = 'squirrelWarsSaveData';
        
        const audioTap = new Audio('audio/click.mp3');
        audioTap.volume = 0.2; 
        
        const playSound = (audioElement) => {
            if (!audioElement) return; 
            audioElement.currentTime = 0;
            audioElement.play().catch(e => console.log("")); 
        };
        
        const RAID_ENERGY_COST = 250;
        const RAID_DURATION_SECONDS = 30;
        const GOLDEN_NUT_INTERVAL_S = 600; 
        const GOLDEN_NUT_DURATION_S = 10; 
        const NUT_SIZE = 75; 
        
        const BASE_BOT_RATE = 10; 
        
        const MAX_LEVEL_TAP = 100;
        const MAX_LEVEL_ENERGY_LIMIT = 20;
        const MAX_LEVEL_ENERGY_RECHARGE = 20;
        const BASE_ENERGY = 1000;
        const ENERGY_LIMIT_PER_LEVEL = 250;
        const ENERGY_RECHARGE_PER_LEVEL = 0.2;
        
        // --- ПЕРЕНОС РАСЧЕТА БОНУСОВ ВНЕ useEffect для корректного использования в расчетах ---
        
        const calculateStats = (levels, permBonusLimit) => {
             const baseTap = (1 + levels.multitap * 1 + 0); // permBonusClick не может быть рассчитан здесь
             const maxEnergy = BASE_ENERGY + levels.energyLimit * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
             const rechargeRate = (1 + levels.energyRecharge * ENERGY_RECHARGE_PER_LEVEL) + 0 + 0; // rechargeBonus, permBonusRecharge не могут быть рассчитаны здесь
             
             return { maxEnergy, rechargeRate, baseTap };
        };
        
        // ----------------------------------------------------------------------------------------

        const BOOST_CATALOG = {
            multitap: { id: 'multitap', name: 'Крепкие Зубы', description: `Добыча +1 $NUT за тап (макс. ${MAX_LEVEL_TAP})`, baseCost: 500, icon: 'images/icon_multitap.png', type: 'level', maxLevel: MAX_LEVEL_TAP, emoji: '🦷' },
            energyLimit: { id: 'energyLimit', name: 'Запасливость', description: `Макс. ⚡️Энергия +${ENERGY_LIMIT_PER_LEVEL} (макс. ${MAX_LEVEL_ENERGY_LIMIT})`, baseCost: 5000, icon: 'images/icon_energy_limit.png', type: 'level', maxLevel: MAX_LEVEL_ENERGY_LIMIT, emoji: '🔋' },
            energyRecharge: { id: 'energyRecharge', name: 'Шустрые Лапки', description: `Скорость регенерации +${ENERGY_RECHARGE_PER_LEVEL}/сек (макс. ${MAX_LEVEL_ENERGY_RECHARGE})`, baseCost: 5000, icon: 'images/icon_energy_recharge.png', type: 'level', maxLevel: MAX_LEVEL_ENERGY_RECHARGE, emoji: '⚡' },
            autoBot: { id: 'autoBot', name: 'Белка-Робот', description: `Доход: +${BASE_BOT_RATE}/сек. Оффлайн работает не более 2ч.`, baseCost: 1000000, icon: 'images/icon_autotap_bot.png', type: 'once', maxLevel: 1 }
        };


        const DEFENSE_CATALOG = {
            baseHp: { id: 'baseHp', name: 'Укрепить Стенки', description: 'Прочность Дупла +1000 HP', baseCost: 300, icon: 'images/icon_base_hp.png', type: 'level', emoji: '🧱' },
            vault: { id: 'vault', name: 'Увеличить Сейф', description: 'Вместимость Сейфа +1000 $NUT', baseCost: 1000, icon: 'images/icon_vault.png', type: 'level', emoji: '💰' }
        };
        
        const TASK_CATALOG = {
            'tap_chain': [
                { id: 'tap_1', name: 'Первый хруст', type: 'tap', target: 100, reward: 150, icon: '👆', details: 'Просто нажмите на белку 100 раз, чтобы получить свою первую награду.' },
                { id: 'tap_2', name: 'Мастер клика', type: 'tap', target: 500, reward: 500, icon: '👆', details: 'Продолжайте тапать! Достигните 500 кликов для следующего приза.' },
                { id: 'tap_3', name: 'Повелитель орехов', type: 'tap', target: 1000, reward: 1000, icon: '👆', details: '1000 кликов покажут, что вы серьезно настроены.' },
                { id: 'tap_4', name: 'Турбо-палец', type: 'tap', target: 5000, reward: 2000, icon: '👆', details: '5000 кликов! Ваши пальцы еще не устали?' },
                { id: 'tap_5', name: 'Марафонец', type: 'tap', target: 10000, reward: 5000, icon: '👆', details: '10,000 кликов. Впечатляющая выносливость!' },
                { id: 'tap_6', name: 'Палец в огне', type: 'tap', target: 25000, reward: 10000, icon: '👆', details: '25,000 кликов. Вы в огне!' },
                { id: 'tap_7', name: 'Машина для кликов', type: 'tap', target: 50000, reward: 15000, icon: '👆', details: '50,000. Вы уже почти робот.' },
                { id: 'tap_8', name: 'Щелкунчик', type: 'tap', target: 100000, reward: 25000, icon: '👆', details: '100,000 кликов. Орехи трещат от страха!' },
                { id: 'tap_9', name: 'Тап-ниндзя', type: 'tap', target: 500000, reward: 50000, icon: '👆', details: '500,000. Легендарная скорость.' },
                { id: 'tap_10', name: 'Бог Кликеров', type: 'tap', target: 1000000, reward: 100000, icon: '👆', details: '1,000,000 кликов. Вы... вы прошли игру?' }
            ],
            'balance_chain': [
                { id: 'bal_1', name: 'Зажиточная белка (I)', type: 'balance', target: 1000, reward: { type: 'double_income', name: 'Двойной доход', duration: 15 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 1 000 $NUT.' },
                { id: 'bal_2', name: 'Зажиточная белка (II)', type: 'balance', target: 10000, reward: { type: 'double_income', name: 'Двойной доход', duration: 30 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 10 000 $NUT.' },
                { id: 'bal_3', name: 'Зажиточная белка (III)', type: 'balance', target: 100000, reward: { type: 'double_income', name: 'Двойной доход', duration: 45 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 100 000 $NUT.' },
                { id: 'bal_4', name: 'Белка-Капиталист (IV)', type: 'balance', target: 250000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 250 000 $NUT.' },
                { id: 'bal_5', name: 'Полный сейф (V)', type: 'balance', target: 500000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 500 000 $NUT.' },
                { id: 'bal_6', name: 'Белка-Миллионер (VI)', type: 'balance', target: 1000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 1 000 000 $NUT.' },
                { id: 'bal_7', name: 'Инвестор (VII)', type: 'balance', target: 5000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 5 000 000 $NUT.' },
                { id: 'bal_8', name: 'Магнат (VIII)', type: 'balance', target: 10000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 10 000 000 $NUT.' },
                { id: 'bal_9', name: 'Олигарх (IX)', type: 'balance', target: 50000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 50 000 000 $NUT.' },
                { id: 'bal_10', name: 'Король Белок (X)', type: 'balance', target: 100000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 100 000 000 $NUT.' }
            ],
            'total_earned_chain': [
                { id: 'earn_1', name: 'Первые деньги', type: 'milestone', target: 1000, reward: { type: 'click', value: 1 }, icon: '📈', details: 'Заработайте 1 000 $NUT (всего). Награда: +1 к силе клика (Навсегда).' },
                { id: 'earn_2', name: 'Полная копилка', type: 'milestone', target: 10000, reward: { type: 'click', value: 3 }, icon: '📈', details: 'Заработайте 10 000 $NUT (всего). Награда: +3 к силе клика (Навсегда).' },
                { id: 'earn_3', name: 'Состоятельная белка', type: 'milestone', target: 100000, reward: { type: 'click', value: 5 }, icon: '📈', details: 'Заработайте 100 000 $NUT (всего). Награда: +5 к силе клика (Навсегда).' },
                { id: 'earn_4', name: 'Первый миллион', type: 'milestone', target: 1000000, reward: { type: 'recharge', value: 1 }, icon: '📈', details: 'Заработайте 1 000 000 $NUT (всего). Награда: +1 ⚡️/сек (Навсегда).' },
                { id: 'earn_5', name: 'Полный сейф', type: 'milestone', target: 10000000, reward: { type: 'limit', value: 500 }, icon: '📈', details: 'Заработайте 10 000 000 $NUT (всего). Награда: +500 ⚡️ макс. (Навсегда).' },
                { id: 'earn_6', name: 'Миллионер', type: 'milestone', target: 100000000, reward: { type: 'limit', value: 1000 }, icon: '📈', details: 'Заработайте 100 000 000 $NUT (всего). Награда: +1000 ⚡️ макс. (Навсегда).' },
                { id: 'earn_7', name: 'Первый миллиард', type: 'milestone', target: 1000000000, reward: { type: 'limit', value: 1500 }, icon: '📈', details: 'Заработайте 1 000 000 000 $NUT (всего). Награда: +1500 ⚡️ макс. (Навсегда).' },
                { id: 'earn_8', name: 'Ореховый Магнат', type: 'milestone', target: 10000000000, reward: { type: 'limit', value: 2000 }, icon: '📈', details: 'Заработайте 10 000 000 000 $NUT (всего). Награда: +2000 ⚡️ макс. (Навсегда).' },
                { id: 'earn_9', name: 'Планетарный Банкир', type: 'milestone', target: 100000000000, reward: { type: 'limit', value: 2500 }, icon: '📈', details: 'Заработайте 100 000 000 000 $NUT (всего). Награда: +2500 ⚡️ макс. (Навсегда).' },
                { id: 'earn_10', name: 'Владыка $NUT', type: 'milestone', target: 1000000000000, reward: { type: 'limit', value: 3000 }, icon: '📈', details: 'Заработайте 1 000 000 000 000 $NUT (всего). Награда: +3000 ⚡️ макс. (Навсегда).' }
            ]
        };
        
        const INITIAL_RAID_LOG = [
             { id: 1, type: 'win', amount: 0, target: 'Белка_Вася' },
        ];
        
        const INITIAL_FRIENDS_LIST = [
            { id: 101, name: 'Белка_Друг1', contribution: 0 },
        ];

        // ===>>> ИСПРАВЛЕНА ФУНКЦИЯ calculateCost <<<===
        const calculateCost = (baseCost, level, upgradeId) => {
            if (upgradeId === 'multitap') {
                if (level <= 40) {
                    return Math.floor(baseCost * Math.pow(1.5, level));
                } else if (level <= 60) {
                    const baseAt40 = baseCost * Math.pow(1.5, 40);
                    return Math.floor(baseAt40 * Math.pow(1.2, level - 40));
                } else if (level <= 80) {
                    const baseAt40 = baseCost * Math.pow(1.5, 40);
                    const baseAt60 = baseAt40 * Math.pow(1.2, 20); 
                    return Math.floor(baseAt60 * Math.pow(1.15, level - 60));
                } else if (level <= 100) {
                    const baseAt40 = baseCost * Math.pow(1.5, 40);
                    const baseAt60 = baseAt40 * Math.pow(1.2, 20);
                    const baseAt80 = baseAt60 * Math.pow(1.15, 20); 
                    return Math.floor(baseAt80 * Math.pow(1.1, level - 80));
                } else {
                    const baseAt40 = baseCost * Math.pow(1.5, 40);
                    const baseAt60 = baseAt40 * Math.pow(1.2, 20);
                    const baseAt80 = baseAt60 * Math.pow(1.15, 20);
                    const baseAt100 = baseAt80 * Math.pow(1.1, 20); 
                    return Math.floor(baseAt100); 
                }
            } else {
                return Math.floor(baseCost * Math.pow(1.5, level));
            }
        };


        const calculateBaseHp = (level) => {
            return 1000 + level * 1000;
        };

        const formatBalance = (num) => {
             if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + ' млрд';
            }
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1).replace(/\.0$/, '') + ' млн';
            }
            if (num >= 10000) { 
                return (num / 1000).toFixed(1).replace(/\.0$/, '') + ' K';
            }
            return num.toLocaleString('ru-RU');
        };
        
        const getMilestoneRewardText = (reward) => {
            if (reward.type === 'click') return `+${reward.value} Клик`;
            if (reward.type === 'recharge') return `+${reward.value} ⚡️/сек`;
            if (reward.type === 'limit') return `+${reward.value} ⚡️`;
            return '...';
        };
        
        const defaultLevels = {
            multitap: 0, 
            energyLimit: 0, 
            energyRecharge: 0, 
            autoBot: 0,
            baseHp: 2,
            vault: 1
        };
        const defaultTaskLevels = { tap_chain: 0, balance_chain: 0, total_earned_chain: 0 };
        const defaultDailyRewardsState = { currentDay: 0, lastClaimedTimestamp: null };


        // =================================================================
        // Главный Компонент Игры (App)
        // =================================================================
        function App() {
            
            const [activeTab, setActiveTab] = useState('forest');
            const [balance, setBalance] = useState(0); 
            const [energy, setEnergy] = useState(BASE_ENERGY); 
            const [tapAnimations, setTapAnimations] = useState([]); 
            
            const [showBotModal, setShowBotModal] = useState(false);
            const [showUpgradeModal, setShowUpgradeModal] = useState(null); 
            const [showBonusModal, setShowBonusModal] = useState(null); 
            
            const [showGoldenNut, setShowGoldenNut] = useState(false);
            const [activeBonuses, setActiveBonuses] = useState([]); 
            const [nutPosition, setNutPosition] = useState({ x: 50, y: 50, isMovingUp: true }); 
            
            const [totalTaps, setTotalTaps] = useState(0); 
            const [totalEarned, setTotalEarned] = useState(0);
            const [taskLevels, setTaskLevels] = useState(defaultTaskLevels); 
            const [showTasksModal, setShowTasksModal] = useState(false);
            const [showTaskClaimModal, setShowTaskClaimModal] = useState(null);
            
            const [levels, setLevels] = useState(defaultLevels);
            
            const [dailyRewardsState, setDailyRewardsState] = useState(defaultDailyRewardsState); 
            const [isDailyRewardAvailable, setIsDailyRewardAvailable] = useState(false);
            const [showDailyRewardsModal, setShowDailyRewardsModal] = useState(false);
            
            const [showComeBackModal, setShowComeBackModal] = useState(false); 
            
            const [showSettingsModal, setShowSettingsModal] = useState(false);
            
            const [isDataLoaded, setIsDataLoaded] = useState(false);
            
            const [musicVolume, setMusicVolume] = useState(50); 
            const [musicStarted, setMusicStarted] = useState(false);
            const audioMusicRef = useRef(new Audio('audio/music.mp3')); 
            
            const [offlineEarnings, setOfflineEarnings] = useState(0);
            const [showOfflineModal, setShowOfflineModal] = useState(false);
            
            const [raidStatus, setRaidStatus] = useState('idle'); 
            const [raidLog, setRaidLog] = useState(INITIAL_RAID_LOG);
            const [friendsList, setFriendsList] = useState(INITIAL_FRIENDS_LIST);
            
            
            // --- РАСЧЕТЫ БОНУСОВ ---
            let tapMultiplier = 1;
            let doubleIncomeMultiplier = 1;
            let rechargeBonus = 0; 
            let permBonusClick = 0;
            let permBonusRecharge = 0;
            let permBonusLimit = 0;
            
            const completedMilestones = TASK_CATALOG.total_earned_chain.slice(0, taskLevels.total_earned_chain);
            completedMilestones.forEach(task => {
                if (task.reward.type === 'click') permBonusClick += task.reward.value;
                if (task.reward.type === 'recharge') permBonusRecharge += task.reward.value;
                if (task.reward.type === 'limit') permBonusLimit += task.reward.value;
            });
            
            activeBonuses.forEach(bonus => {
                if (bonus.type === 'madness') tapMultiplier = bonus.multiplier;
                else if (bonus.type === 'speed') rechargeBonus = bonus.rate;
                else if (bonus.type === 'double_income') doubleIncomeMultiplier = 2;
            });
            
            const baseTap = (1 + levels.multitap * 1 + permBonusClick);
            const tapValue = Math.floor((baseTap) * tapMultiplier * doubleIncomeMultiplier); 
            const maxEnergy = BASE_ENERGY + levels.energyLimit * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
            const rechargeRate = (1 + levels.energyRecharge * ENERGY_RECHARGE_PER_LEVEL) + rechargeBonus + permBonusRecharge; 
            const passiveRatePerSec = levels.autoBot > 0 ? BASE_BOT_RATE : 0; 

            const currentTapTask = TASK_CATALOG.tap_chain[taskLevels.tap_chain];
            const currentBalanceTask = TASK_CATALOG.balance_chain[taskLevels.balance_chain];
            const currentEarnedTask = TASK_CATALOG.total_earned_chain[taskLevels.total_earned_chain];
            
            const completedTapTasks = (currentTapTask && totalTaps >= currentTapTask.target) ? 1 : 0;
            const completedBalanceTasks = (currentBalanceTask && balance >= currentBalanceTask.target) ? 1 : 0;
            const completedMilestoneTasks = (currentEarnedTask && totalEarned >= currentEarnedTask.target) ? 1 : 0;
            
            const completedTaskCount = completedTapTasks + completedBalanceTasks + completedMilestoneTasks;
            
            
            useEffect(() => {
                const data = localStorage.getItem(SAVE_DATA_KEY);
                let savedData = null;
                
                // 1. Попытка загрузить данные
                if (data) {
                    try {
                        savedData = JSON.parse(data);
                    } catch (e) {
                        console.error("Ошибка парсинга JSON из localStorage", e);
                        localStorage.removeItem(SAVE_DATA_KEY); 
                    }
                }
                
                // --- ГАРАНТИРОВАННАЯ ИНИЦИАЛИЗАЦИЯ И УСТРАНЕНИЕ ОШИБКИ ЧЕРНОГО ЭКРАНА ---
                let initialLevels = savedData ? savedData.levels || defaultLevels : defaultLevels;
                let initialTaskLevels = savedData ? savedData.taskLevels || defaultTaskLevels : defaultTaskLevels;
                
                // 2. Расчет перманентных бонусов на основе загруженных уровней
                let tempPermBonusLimit = 0;
                let tempPermBonusRecharge = 0;
                
                // Защита от undefined: проверяем существование элемента в массиве, прежде чем его slice'ить
                if (initialTaskLevels.total_earned_chain !== undefined) {
                    const completedM = TASK_CATALOG.total_earned_chain.slice(0, initialTaskLevels.total_earned_chain);
                    completedM.forEach(task => {
                        if (task.reward.type === 'recharge') tempPermBonusRecharge += task.reward.value;
                        if (task.reward.type === 'limit') tempPermBonusLimit += task.reward.value;
                    });
                }


                // Рассчитываем максимальную энергию и скорость регенерации с учетом loaded levels
                const calculatedMaxEnergy = BASE_ENERGY + initialLevels.energyLimit * ENERGY_LIMIT_PER_LEVEL + tempPermBonusLimit;
                const calculatedRechargeRate = (1 + initialLevels.energyRecharge * ENERGY_RECHARGE_PER_LEVEL) + tempPermBonusRecharge; 

                // 3. Инициализация Энергии и Офлайн-Регенерация
                let loadedEnergy = BASE_ENERGY; // Дефолт для нового игрока
                
                if (savedData) {
                    // Используем savedData.energy, если оно есть, ИНАЧЕ 0.
                    // ЭТО РЕШАЕТ ПРОБЛЕМУ СКАЧКА ДО 1000, т.к. если игрок играл, savedEnergy будет 
                    // либо текущим, либо 0. Если он новый, то initial Energy будет BASE_ENERGY (1000).
                    const savedEnergy = savedData.energy !== undefined ? savedData.energy : 0; 
                    const lastOnlineTimestamp = savedData.lastOnlineTimestamp || Date.now();
                    const timeDiffSeconds = Math.floor((Date.now() - lastOnlineTimestamp) / 1000);
                    
                    if (timeDiffSeconds > 0) {
                        const regeneratedEnergy = timeDiffSeconds * calculatedRechargeRate;
                        // Регенерируем энергию, но не превышаем Максимальный лимит
                        loadedEnergy = Math.min(savedEnergy + regeneratedEnergy, calculatedMaxEnergy);
                    } else {
                        loadedEnergy = savedEnergy;
                    }
                    
                    // Устанавливаем все остальные данные
                    setBalance(savedData.balance || 0);
                    setDailyRewardsState(savedData.dailyRewardsState || defaultDailyRewardsState);
                    setTotalTaps(savedData.totalTaps || 0);
                    setTotalEarned(savedData.totalEarned || 0);
                    setMusicVolume(savedData.musicVolume !== undefined ? savedData.musicVolume : 50);

                    // Расчет офлайн-дохода от Робота (остается без изменений)
                    if (initialLevels.autoBot > 0) {
                        const maxOfflineTime = 7200; 
                        const effectiveTime = Math.min(timeDiffSeconds, maxOfflineTime);
                        const earnings = Math.floor(effectiveTime * BASE_BOT_RATE);

                        if (earnings > 0) {
                            setOfflineEarnings(earnings); 
                            setShowOfflineModal(true);  
                        }
                    }
                }
                
                // Устанавливаем все состояния
                setLevels(initialLevels);
                setTaskLevels(initialTaskLevels);
                setEnergy(loadedEnergy); 

                const savedTimestamp = (savedData && savedData.dailyRewardsState) ? savedData.dailyRewardsState.lastClaimedTimestamp : null;
                const today = new Date().toDateString(); 
                const lastClaimedDate = savedTimestamp ? new Date(savedTimestamp).toDateString() : null;
                
                if (today !== lastClaimedDate) {
                    setIsDailyRewardAvailable(true); 
                }
                
                setIsDataLoaded(true); 
            }, []); 
            
            // Сохранение данных (использует energy, которую мы корректно загрузили/рассчитали)
            useEffect(() => {
                if (isDataLoaded) { 
                    const dataToSave = {
                        balance,
                        energy, 
                        levels,
                        taskLevels,
                        dailyRewardsState,
                        totalTaps,
                        totalEarned,
                        musicVolume, 
                        lastOnlineTimestamp: Date.now() 
                    };
                    localStorage.setItem(SAVE_DATA_KEY, JSON.stringify(dataToSave));
                }
            }, [balance, energy, levels, taskLevels, dailyRewardsState, totalTaps, totalEarned, isDataLoaded, musicVolume]);


            
            useEffect(() => {
                const timer = setInterval(() => {
                    setEnergy(currentEnergy => 
                        Math.min(maxEnergy, currentEnergy + rechargeRate)
                    );
                    
                    if (passiveRatePerSec > 0) {
                        const income = passiveRatePerSec; 
                        setBalance(currentBalance => currentBalance + income);
                        setTotalEarned(t => t + income); 

                        const newTap = {
                            id: tapIdCounter++,
                            value: `+${income} (Bot)`,
                            x: 250, 
                            y: 250,
                            color: 'lightblue',
                            isPassive: true
                        };
                        setTapAnimations(prev => [...prev, newTap]);

                        setTimeout(() => {
                            setTapAnimations(prev => prev.filter(tap => tap.id !== newTap.id));
                        }, 1000);
                    }
                    
                }, 1000);
                
                return () => clearInterval(timer);
            }, [maxEnergy, rechargeRate, passiveRatePerSec]); 
            
            useEffect(() => {
                const MAX_X = 90; 
                const MIN_X = 5;
                const MIN_Y = 15; 
                const MAX_Y = 85; 
                
                let nutTimeoutId; 
                
                const generateInitialPosition = () => {
                    const startX = Math.floor(Math.random() * (MAX_X - MIN_X) + MIN_X);
                    const startY = Math.floor(Math.random() * (MAX_Y - MIN_Y) + MIN_Y);
                    
                    return { x: startX, y: startY, isMovingUp: Math.random() > 0.5 };
                };
                
                const showNut = () => {
                     setNutPosition(generateInitialPosition());
                     setShowGoldenNut(true);
                     
                     nutTimeoutId = setTimeout(() => {
                         setShowGoldenNut(false);
                     }, GOLDEN_NUT_DURATION_S * 1000); 
                };
                
                const initialTimeout = setTimeout(showNut, 10000); 
                const intervalId = setInterval(showNut, GOLDEN_NUT_INTERVAL_S * 1000); 
                
                return () => {
                    clearTimeout(initialTimeout);
                    clearInterval(intervalId);
                    clearTimeout(nutTimeoutId);
                };
            }, [showGoldenNut]); 

            useEffect(() => {
                let nutMoveIntervalId;
                
                if (showGoldenNut) {
                    const MAX_X = 90; 
                    const MIN_X = 5;
                    const MIN_Y = 15; 
                    const MAX_Y = 85; 
                    const Y_SPEED = 5; 
                    const X_DRIFT = 10; 

                    const moveNut = () => {
                        setNutPosition(prevPos => {
                            let newY = prevPos.y;
                            let newX = prevPos.x;
                            let isMovingUp = prevPos.isMovingUp;

                            if (isMovingUp) {
                                newY -= Y_SPEED;
                                if (newY <= MIN_Y) { 
                                    newY = MIN_Y;
                                    isMovingUp = false; 
                                }
                            } else {
                                newY += Y_SPEED;
                                if (newY >= MAX_Y) { 
                                    newY = MAX_Y;
                                    isMovingUp = true; 
                                }
                            }
                            
                            newX += (Math.random() * X_DRIFT * 2) - X_DRIFT; 
                            newX = Math.max(MIN_X, Math.min(MAX_X, newX));

                            return { x: newX, y: newY, isMovingUp: isMovingUp };
                        });
                    };
                    
                    nutMoveIntervalId = setInterval(moveNut, 1000);
                }

                return () => {
                    clearInterval(nutMoveIntervalId); 
                };
            }, [showGoldenNut]); 
            
            useEffect(() => {
                audioMusicRef.current.loop = true;
                audioMusicRef.current.volume = musicVolume / 100;
                
                if (musicVolume > 0 && musicStarted) {
                    audioMusicRef.current.play().catch(e => console.error("Ошибка воспроизведения музыки:", e));
                } else {
                    audioMusicRef.current.pause();
                }
            }, [musicVolume, musicStarted]);
            
            
            const handleGoldenNutClick = (e) => {
                 e.stopPropagation(); 

                 if (!showGoldenNut) return;
                 setShowGoldenNut(false);
                 
                 const bonuses = [
                     { type: 'instant', name: 'Орехопад', value: 1000, duration: 0 },
                     { type: 'madness', name: 'Безумие', multiplier: 10, duration: 10 },
                     { type: 'speed', name: 'Ускорение', rate: 15, duration: 10 },
                 ];
                 
                 const chosenBonus = bonuses[Math.floor(Math.random() * bonuses.length)];

                 if (chosenBonus.type === 'instant') {
                     setBalance(b => b + chosenBonus.value);
                     setTotalEarned(t => t + chosenBonus.value); 
                     setShowBonusModal({ 
                         icon: '🎉', 
                         title: chosenBonus.name, 
                         message: `Вы получили ${chosenBonus.value} $NUT!`, 
                         button: 'Забрать' 
                     });
                 } else {
                     setActiveBonuses(prev => [...prev, chosenBonus]);
                     
                     let message = '';
                     if (chosenBonus.type === 'madness') {
                         message = `Ваш клик в ${chosenBonus.multiplier} раз сильнее на ${chosenBonus.duration} секунд!`;
                     } else if (chosenBonus.type === 'speed') {
                         message = `Регенерация энергии +${chosenBonus.rate}/сек на ${chosenBonus.duration} секунд!`;
                     }
                     
                     setShowBonusModal({ 
                         icon: '⚡', 
                         title: chosenBonus.name, 
                         message: message, 
                         button: 'Отлично!' 
                     });
                     
                     setTimeout(() => {
                         setActiveBonuses(prev => prev.filter(b => b.name !== chosenBonus.name));
                         setShowBonusModal({
                             icon: '🕰️',
                             title: 'Бонус Завершился',
                             message: `Действие бонуса «${chosenBonus.name}» закончилось.`, 
                             button: 'Продолжить'
                         });
                     }, chosenBonus.duration * 1000);
                 }
            };
            
            // --- НОВЫЙ ЕДИНЫЙ ОБРАБОТЧИК ДЛЯ КЛИКОВ И ТАЧЕЙ ---
            const processTap = (tapCount, clientX, clientY, gameScreen) => {
                if (!musicStarted) {
                    if (musicVolume > 0) { 
                         audioMusicRef.current.play().catch(e => console.error("Ошибка воспроизведения музыки:", e));
                    }
                    setMusicStarted(true);
                }
                
                if (activeTab !== 'forest' && activeTab !== 'raid') return; 

                // Определяем общее количество кликов/тапов
                const tapsToProcess = Math.min(tapCount, energy); 
                if (tapsToProcess <= 0) return;
                
                if (activeTab === 'raid' && raidStatus === 'battle') {
                     // Логика рейдов остается заблокированной
                     // handleRaidTap(tapsToProcess);
                     return;
                }
                
                if (activeTab === 'forest' && energy >= tapsToProcess) { 
                    setEnergy(e => e - tapsToProcess);
                    setTotalTaps(t => t + tapsToProcess);

                    let totalValue = 0;
                    const newAnimations = [];
                    const rect = gameScreen.getBoundingClientRect();
                    
                    for (let i = 0; i < tapsToProcess; i++) {
                        const isCritical = Math.random() < 0.01; 
                        const critMultiplier = 5;
                        const currentTapValue = isCritical ? (tapValue * critMultiplier) : tapValue;
                        totalValue += currentTapValue;
                        
                        // Случайное смещение для каждой анимации, чтобы они не накладывались
                        const animationX = clientX + (Math.random() * 20 - 10);
                        const animationY = clientY + (Math.random() * 20 - 10);

                        newAnimations.push({
                            id: tapIdCounter++,
                            value: `+${currentTapValue}`, 
                            x: animationX - rect.left,
                            y: animationY - rect.top,
                            isCritical: isCritical 
                        });
                    }

                    playSound(audioTap);
                    setBalance(b => b + totalValue);
                    setTotalEarned(t => t + totalValue);

                    setTapAnimations(prev => [...prev, ...newAnimations]);

                    // Удаляем анимации через 1 секунду
                    setTimeout(() => {
                        setTapAnimations(prev => prev.filter(tap => !newAnimations.includes(tap)));
                    }, 1000);
                }
            };

            // 1. Для кликов мышью (на десктопе)
            const handleTap = (e) => {
                // Игнорируем нажатия на золотой орех, если он активен
                if (e.target.closest('.golden-nut-container')) {
                    handleGoldenNutClick(e); 
                    return;
                }
                
                const gameScreen = e.currentTarget.closest('.game-screen');
                processTap(1, e.clientX, e.clientY, gameScreen);
            };

            // 2. Для тапов (мультитач на мобильных)
            const handleTouchStart = (e) => {
                e.preventDefault(); // Предотвращаем стандартное действие браузера (например, масштабирование)
                
                // Игнорируем нажатия на золотой орех, если он активен
                if (e.target.closest('.golden-nut-container')) {
                    handleGoldenNutClick(e); 
                    return;
                }
                
                const tapCount = e.touches.length; // Количество пальцев на экране
                const gameScreen = e.currentTarget.closest('.game-screen');
                
                // Используем координаты первого касания для анимации, но засчитываем все
                if (e.touches[0]) {
                    processTap(tapCount, e.touches[0].clientX, e.touches[0].clientY, gameScreen);
                }
            };
            // --- КОНЕЦ ЕДИНОГО ОБРАБОТЧИКА ---

            
            const handleBuyUpgrade = (catalog, upgradeId) => {
                const upgrade = catalog[upgradeId];
                const currentLevel = levels[upgradeId];
                
                const isMaxLevel = upgrade.type === 'level' && currentLevel >= upgrade.maxLevel;
                
                if (upgrade.type === 'once' && currentLevel > 0) {
                    alert('Этот буст уже куплен!');
                    return;
                }
                
                if (isMaxLevel) {
                     setShowUpgradeModal({ id: upgradeId, level: currentLevel, isMax: true });
                     return;
                }

                const cost = upgrade.type === 'once' 
                    ? upgrade.baseCost 
                    : calculateCost(upgrade.baseCost, currentLevel, upgradeId);
                
                if (balance >= cost) {
                    setBalance(balance - cost);
                    setLevels(prevLevels => ({
                        ...prevLevels,
                        [upgradeId]: upgrade.type === 'once' ? 1 : prevLevels[upgradeId] + 1
                    }));

                    if (upgradeId === 'autoBot' && upgrade.type === 'once') {
                        setShowBotModal(true); 
                    } else if (upgrade.type === 'level') {
                         const newLevel = currentLevel + 1;
                         const reachedMax = newLevel === upgrade.maxLevel;
                         setShowUpgradeModal({ id: upgradeId, level: newLevel, isMax: reachedMax });
                    }
                    
                    if (upgradeId === 'energyLimit') {
                        // Обновление энергии при покупке лимита
                        const oldMaxEnergy = BASE_ENERGY + currentLevel * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
                        const newMaxEnergy = BASE_ENERGY + (currentLevel + 1) * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
                        const energyRatio = energy / oldMaxEnergy;
                        setEnergy(Math.min(newMaxEnergy, Math.ceil(newMaxEnergy * energyRatio)));
                    }
                    
                } else {
                    alert('Недостаточно $NUT!');
                }
            };

            const handleVaultAction = (action, amount) => {
                // (Логика Сейфа остается заблокированной, т.к. вкладка 'home' заблокирована)
            };
            
            const handleClaimTask = (taskChainId) => {
                let task;
                if (taskChainId === 'tap_chain') {
                    task = TASK_CATALOG.tap_chain[taskLevels.tap_chain];
                    if (task && totalTaps >= task.target) {
                        setShowTaskClaimModal(task);
                        setShowTasksModal(false); 
                    }
                } else if (taskChainId === 'balance_chain') {
                    task = TASK_CATALOG.balance_chain[taskLevels.balance_chain];
                    if (task && balance >= task.target) {
                        setShowTaskClaimModal(task);
                        setShowTasksModal(false); 
                    }
                } else if (taskChainId === 'total_earned_chain') {
                    task = TASK_CATALOG.total_earned_chain[taskLevels.total_earned_chain];
                    if (task && totalEarned >= task.target) {
                        setShowTaskClaimModal(task);
                        setShowTasksModal(false); 
                    }
                }
            };
            
            const confirmClaimTask = (task) => {
                if (task.type === 'tap') {
                    setBalance(b => b + task.reward);
                    setTotalEarned(t => t + task.reward);
                    setTaskLevels(prev => ({
                        ...prev,
                        tap_chain: prev.tap_chain + 1
                    }));
                } else if (task.type === 'balance') {
                    const bonus = { ...task.reward, id: Date.now() };
                    setActiveBonuses(prev => [...prev, bonus]);
                    
                    setTimeout(() => {
                        setActiveBonuses(prev => prev.filter(b => b.id !== bonus.id));
                        setShowBonusModal({
                            icon: '🕰️',
                            title: 'Бонус Завершился',
                            message: `Действие бонуса «${bonus.name}» закончилось.`,
                            button: 'Продолжить'
                        });
                    }, bonus.duration * 1000);
                    
                    setTaskLevels(prev => ({
                        ...prev,
                        balance_chain: prev.balance_chain + 1
                    }));
                } else if (task.type === 'milestone') {
                    setTaskLevels(prev => ({
                        ...prev,
                        total_earned_chain: prev.total_earned_chain + 1
                    }));
                }
                
                setShowTaskClaimModal(null); 
                setActiveTab('forest'); 
            };
            
            const handleClaimDailyReward = () => {
                if (!isDailyRewardAvailable) return;

                const reward = DAILY_REWARDS_CATALOG[dailyRewardsState.currentDay];
                
                if (reward.type === 'nut') {
                    setBalance(b => b + reward.value);
                    setTotalEarned(t => t + reward.value);
                } else if (reward.type === 'bonus') {
                    const bonus = { ...reward.bonus, id: Date.now() };
                    setActiveBonuses(prev => [...prev, bonus]);
                    setTimeout(() => {
                        setActiveBonuses(prev => prev.filter(b => b.id !== bonus.id));
                        setShowBonusModal({
                            icon: '🕰️',
                            title: 'Бонус Завершился',
                            message: `Действие бонуса «${reward.bonus.name}» закончилось.`,
                            button: 'Продолжить'
                        });
                    }, reward.bonus.duration * 1000);
                }

                setDailyRewardsState({
                    currentDay: (dailyRewardsState.currentDay + 1) % 7, 
                    lastClaimedTimestamp: Date.now() 
                });
                setIsDailyRewardAvailable(false); 
                
                setShowDailyRewardsModal(false);
                setShowBonusModal({
                    icon: reward.icon,
                    title: 'Награда получена!',
                    message: `Вы получили: ${reward.label}!`,
                    button: 'Отлично!'
                });
            };

            
            const startRaid = () => { /* ... */ };
            const handleRaidTap = () => { /* ... */ };
            const finishRaid = (isWin) => { /* ... */ };
            const collectFriendBonus = () => { /* ... */ };
            

            // --- Рендеринг (Отрисовка) ---
            
            const renderActiveScreen = () => {
                if (!isDataLoaded) {
                    // Пока данные не загружены, показываем черный экран или заглушку
                    return <div style={{flexGrow: 1, backgroundColor: '#1a1a1a'}}></div>; 
                }
                
                switch(activeTab) {
                    case 'forest':
                        return (
                            <div 
                                className="forest-content" 
                                onClick={handleTap} 
                                onTouchStart={handleTouchStart} 
                            >
                                <ForestScreen 
                                    onTasksClick={() => setShowTasksModal(true)} 
                                    completedTasks={completedTaskCount}
                                    onDailyRewardClick={() => setShowDailyRewardsModal(true)}
                                    isDailyRewardAvailable={isDailyRewardAvailable}
                                    onSettingsClick={() => setShowSettingsModal(true)}
                                />
                                
                                {activeBonuses.length > 0 && (
                                    <div className="active-bonus-indicator">
                                        {activeBonuses.map(bonus => (
                                            <div key={bonus.name} className="bonus-indicator-item">
                                                {/* ИСПРАВЛЕНИЕ: Объединяем текст в одну строку */}
                                                <span className="bonus-indicator-subtext">
                                                    ⚡️ {bonus.name} 
                                                    {bonus.type === 'madness' && <span> x{bonus.multiplier} к клику!</span>}
                                                    {bonus.type === 'speed' && <span> +{bonus.rate} ⚡️/сек!</span>}
                                                </span>
                                            </div>
                                        ))}
                                    </div>
                                )}
                                
                                {showGoldenNut && (
                                    <div 
                                        className="golden-nut-container"
                                        onClick={handleGoldenNutClick}
                                        style={{ 
                                            top: `${nutPosition.y}%`,
                                            left: `${nutPosition.x}%`,
                                        }}
                                    >
                                        <img src="images/nut_golden_bonus.png" alt="Golden Nut" />
                                    </div>
                                )}

                                {tapAnimations.filter(t => t.color !== 'red' && !t.isPassive).map(tap => (
                                    <TapAnimation 
                                        key={tap.id} 
                                        value={tap.value} 
                                        x={tap.x} 
                                        y={tap.y} 
                                        isCritical={tap.isCritical}
                                    />
                                ))}
                                {tapAnimations.filter(t => t.isPassive).map(tap => (
                                    <TapAnimation 
                                        key={tap.id} 
                                        value={tap.value} 
                                        x={tap.x} 
                                        y={tap.y} 
                                        color={tap.color} 
                                    />
                                ))}
                            </div>
                        );
                    case 'boosts':
                        return (
                            <div className="game-screen-scroll">
                                <BoostsScreen 
                                    levels={levels} 
                                    balance={balance} 
                                    passiveRatePerSec={passiveRatePerSec}
                                    onBuy={(id) => handleBuyUpgrade(BOOST_CATALOG, id)}
                                    
                                    permBonusClick={permBonusClick}
                                    permBonusLimit={permBonusLimit}
                                    permBonusRecharge={permBonusRecharge}
                                />
                            </div>
                        );
                    case 'raid':
                    case 'home':
                    case 'squad':
                        return <LockedScreen tab={activeTab} />;
                    default:
                        return <div className="forest-content" onClick={handleTap} onTouchStart={handleTouchStart}><ForestScreen /></div>;
                }
            };
            
            return (
                <div className="app-container">
                    
                    <Header 
                        balance={balance} 
                        passiveRate={passiveRatePerSec} 
                    />
                    
                    <div className="game-screen">
                        {renderActiveScreen()}
                    </div>
                    
                    {showBotModal && <BotPurchaseModal onClose={() => setShowBotModal(false)} rate={BASE_BOT_RATE} />}
                    {showUpgradeModal && (
                        <UpgradeSuccessModal 
                            upgradeId={showUpgradeModal.id}
                            newLevel={showUpgradeModal.level}
                            isMax={showUpgradeModal.isMax}
                            onClose={() => setShowUpgradeModal(null)}
                        />
                    )}
                    {showBonusModal && (
                        <BonusNotificationModal 
                            details={showBonusModal}
                            onClose={() => setShowBonusModal(null)}
                        />
                    )}
                    {showTasksModal && (
                        <TasksModal 
                            onClose={() => setShowTasksModal(false)}
                            totalTaps={totalTaps}
                            balance={balance} 
                            totalEarned={totalEarned} 
                            taskLevels={taskLevels}
                            onClaim={handleClaimTask}
                            completedTapTasks={completedTapTasks}
                            completedBalanceTasks={completedBalanceTasks}
                            completedMilestoneTasks={completedMilestoneTasks}
                        />
                    )}
                    
                    {showTaskClaimModal && (
                        <TaskClaimModal
                            task={showTaskClaimModal}
                            onClaim={() => confirmClaimTask(showTaskClaimModal)}
                            onClose={() => setShowTaskClaimModal(null)}
                        />
                    )}
                    
                    {showDailyRewardsModal && (
                        <DailyRewardsModal
                            onClose={() => setShowDailyRewardsModal(false)}
                            rewardsCatalog={DAILY_REWARDS_CATALOG}
                            currentState={dailyRewardsState}
                            isAvailable={isDailyRewardAvailable}
                            onClaim={handleClaimDailyReward}
                            onShowComeBackModal={() => setShowComeBackModal(true)}
                        />
                    )}
                    
                    {showComeBackModal && (
                        <ComeBackTomorrowModal onClose={() => setShowComeBackModal(false)} />
                    )}
                    
                    {showSettingsModal && (
                        <SettingsModal
                            onClose={() => setShowSettingsModal(false)}
                            musicVolume={musicVolume}
                            onVolumeChange={setMusicVolume}
                        />
                    )}
                    
                    {showOfflineModal && (
                        <OfflineEarningsModal
                            earnings={offlineEarnings}
                            onClaim={() => {
                                setBalance(b => b + offlineEarnings);
                                setTotalEarned(t => t + offlineEarnings);
                                setShowOfflineModal(false);
                                setOfflineEarnings(0);
                            }}
                        />
                    )}


                    <EnergyBar energy={energy} maxEnergy={maxEnergy} />

                    <TabBar activeTab={activeTab} onTabClick={setActiveTab} />
                
                </div>
            );
        }


        // =================================================================
        // Компоненты Экранов и UI-элементов
        // =================================================================
        
        function OfflineEarningsModal({ earnings, onClaim }) {
            return (
                <div className="modal-overlay">
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon bot-icon">🤖</div>
                        <h3 className="success">Добро пожаловать!</h3>
                        <p>
                            Пока вас не было, ваша Белка-Робот собрала:
                        </p>
                        <p style={{fontSize: '1.5em', fontWeight: 'bold', color: 'gold', margin: '10px 0 20px 0'}}>
                           + {formatBalance(earnings)} $NUT
                        </p>
                        <button className="buy-btn" onClick={onClaim}>
                            Забрать!
                        </button>
                    </div>
                </div>
            );
        }

        
        function SettingsModal({ onClose, musicVolume, onVolumeChange }) { 
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="settings-modal" onClick={(e) => e.stopPropagation()}>
                        <h2>⚙️ Настройки</h2>
                        
                        <div className="settings-section">
                            <h3>Звук</h3>
                            <div className="settings-toggle-row">
                                <span>Громкость музыки</span>
                                <input 
                                    type="range" 
                                    min="0" 
                                    max="100" 
                                    value={musicVolume} 
                                    onChange={(e) => onVolumeChange(Number(e.target.value))} 
                                />
                                <span>{musicVolume}%</span>
                            </div>
                        </div>

                        <div className="settings-section">
                            <h3>Об игре</h3>
                            <p>
                                <strong>Squirrel Wars</strong> - это кликер.
                            </p>
                        </div>
                        
                        <div className="settings-section">
                            <h3>Обратная связь</h3>
                            <a 
                                href="https://t.me/denzzzz_7" 
                                target="_blank" 
                                rel="noopener noreferrer" 
                                className="settings-button-link"
                                style={{backgroundColor: '#E53935'}}
                            >
                                🐞 Сообщить об ошибке
                            </a>
                        </div>

                    </div>
                </div>
            );
        }

        
        function ComeBackTomorrowModal({ onClose }) {
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon level-icon">🕰️</div>
                        <h3 className="max-level">Награда недоступна</h3>
                        <p>
                            Вы уже получили сегодняшнюю награду.
                            Возвращайтесь завтра!
                        </p>
                        <button className="buy-btn" style={{backgroundColor: '#007BFF'}} onClick={onClose}>
                            Понятно
                        </button>
                    </div>
                </div>
            );
        }

        
        function DailyRewardsModal({ onClose, rewardsCatalog, currentState, isAvailable, onClaim, onShowComeBackModal }) {
            
            const renderItem = (reward, index) => {
                const day = index + 1;
                let status = 'locked'; 
                let icon = '🔒';
                
                if (index < currentState.currentDay) {
                    status = 'claimed';
                    icon = '✅';
                } else if (index === currentState.currentDay && isAvailable) {
                    status = 'available';
                    icon = reward.icon;
                } else {
                    icon = '🔒';
                }
                
                const itemClass = `daily-reward-item ${status} day-${day}`;
                
                if (status === 'available') {
                    return (
                        <button key={day} className={itemClass} onClick={onClaim}>
                            <div className="day-label">День {day}</div>
                            <div className="reward-icon">{icon}</div>
                            <div className="reward-label">{reward.label}</div>
                        </button>
                    );
                }
                
                return (
                    <div 
                        key={day} 
                        className={itemClass}
                        onClick={status === 'locked' ? onShowComeBackModal : null} 
                        style={{ cursor: (status === 'locked') ? 'pointer' : 'default' }}
                    >
                        <div className="day-label">День {day}</div>
                        <div className="reward-icon">{icon}</div>
                        <div className="reward-label">
                            {status === 'claimed' ? reward.label : (status === 'locked' ? '???' : reward.label)}
                        </div>
                    </div>
                );
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="daily-rewards-modal" onClick={(e) => e.stopPropagation()}>
                        <h2>🎁 Ежедневные Награды</h2>
                        <div className="daily-rewards-grid">
                            {rewardsCatalog.map((reward, index) => renderItem(reward, index))}
                        </div>
                        
                        {!isAvailable && (
                            <div style={{marginTop: '20px', textAlign: 'center'}}>
                                <p style={{fontSize: '1.2em', color: 'gold', fontWeight: 'bold'}}>
                                    Следующая награда будет доступна завтра!
                                </p>
                                <button 
                                    className="buy-btn" 
                                    style={{backgroundColor: '#007BFF', marginTop: '10px'}} 
                                    onClick={onClose}
                                >
                                    Закрыть
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        
        function TaskClaimModal({ task, onClaim, onClose }) {
            let rewardMessage = '';
            let title = 'Награда получена!'; 
            let icon = task.icon;
            let buttonText = 'Забрать!';

            if (task.type === 'tap') {
                rewardMessage = `Вы получаете +${formatBalance(task.reward)} $NUT!`;
                icon = '💰';
            } else if (task.type === 'balance') {
                rewardMessage = `Вы активируете бонус "${task.reward.name}" на ${task.reward.duration} секунд!`;
                icon = '⚡';
                buttonText = 'Активировать!';
            } else if (task.type === 'milestone') {
                rewardMessage = `Вы получаете постоянный бонус: ${getMilestoneRewardText(task.reward)}!`;
                icon = '📈';
                buttonText = 'Супер!';
            }

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon level-icon">{icon}</div>
                        <h3 className="success">{title}</h3>
                        <p style={{fontSize: '1.2em', fontWeight: 'bold', color: 'gold', marginBottom: '10px'}}>
                            {task.name}
                        </p>
                        <p>{rewardMessage}</p>
                        <button className="buy-btn" onClick={onClaim}>
                            {buttonText}
                        </button>
                    </div>
                </div>
            );
        }

        
        function BonusNotificationModal({ details, onClose }) {
             const titleClass = details.type === 'instant' 
                ? 'success' 
                : (details.title === 'Бонус Завершился' ? 'ended' : 'max-level');
             const buttonColor = details.type === 'instant' ? '#4CAF50' : '#007BFF';

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon level-icon">{details.icon}</div>
                        <h3 className={titleClass}>{details.title}</h3>
                        <p>
                            {details.message}
                        </p>
                        <button className="buy-btn" style={{backgroundColor: buttonColor}} onClick={onClose}>
                            {details.button}
                        </button>
                    </div>
                </div>
            );
        }

        
        // ===>>> ИЗМЕНЕНИЕ 2: Обновление текста в BotPurchaseModal <<<===
        function BotPurchaseModal({ onClose, rate }) {
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon bot-icon">🤖</div>
                        <h3>Покупка завершена!</h3>
                        <p>
                            Белка-Робот куплен! Он начинает собирать $NUT: 
                            <span style={{color: '#90EE90', fontWeight: 'bold'}}> +{rate} $NUT/сек</span>, 
                            пока вы в игре а также когда офлайн. После 2 часов офлайна останавливает свою работу!
                        </p>
                        <button className="buy-btn" style={{backgroundColor: '#007BFF'}} onClick={onClose}>
                            Отлично!
                        </button>
                    </div>
                </div>
            );
        }
        // ===>>> КОНЕЦ ИЗМЕНЕНИЯ 2 <<<===

        
        function UpgradeSuccessModal({ upgradeId, newLevel, isMax, onClose }) {
            const upgrade = {...BOOST_CATALOG, ...DEFENSE_CATALOG}[upgradeId];
            
            const title = isMax ? "⭐ Максимальный Уровень!" : "Улучшение завершено!";
            const titleClass = isMax ? "max-level" : "success";
            
            const message = isMax 
                ? `Вы достигли максимального уровня (${upgrade.maxLevel || 'MAX'}) для улучшения «${upgrade.name}»!`
                : `Вы успешно улучшили «${upgrade.name}» до уровня ${newLevel}!`;
            
            const icon = isMax ? '👑' : upgrade.emoji;

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon level-icon">{icon}</div>
                        <h3 className={titleClass}>{title}</h3>
                        <p>{message}</p>
                        <button className="buy-btn" onClick={onClose}>
                            Продолжить
                        </button>
                    </div>
                </div>
            );
        }

        
        function LockedScreen({ tab }) {
            const tabName = {
                raid: 'Набег',
                home: 'Дупло',
                squad: 'Стая'
            }[tab];
            
            return (
                <div className="locked-screen-message">
                    <p style={{fontSize: '3em'}}>🔒</p>
                    {tabName && <h3 style={{textAlign: 'center', marginBottom: '15px'}}>{tabName}</h3>}
                    <p style={{fontSize: '1em', color: '#FFD700'}}>
                       Эта функция в разработке и будет доступна позже.
                    </p>
                </div>
            );
        }

        function TapAnimation({ value, x, y, color, isCritical }) {
            const style = {
                left: `${x}px`, 
                top: `${y}px`,
                color: !isCritical ? (color || 'gold') : undefined,
            };
            
            const animationClass = `tap-animation ${isCritical ? 'critical' : ''}`;
            
            return (
                <div 
                    className={animationClass} 
                    style={style}
                >
                    {value}
                </div>
            );
        }

        function Header({ balance, passiveRate }) { 
             const rateDisplay = passiveRate > 0 ? ` (+${passiveRate}/сек)` : '';
             const formattedBalance = formatBalance(balance);

            return (
                <header className="header">
                    <div className="header-user">
                        <img src="images/avatar_placeholder.png" alt="User" />
                        Player_Vasya
                    </div>
                    <div className="header-balance">
                        <img src="images/nut_icon.png" alt="NUT" />
                        {formattedBalance}
                        <span style={{fontSize: '0.6em', color: '#90EE90', fontWeight: 'bold'}}>{rateDisplay}</span>
                    </div>
                </header>
            );
        }

        function EnergyBar({ energy, maxEnergy }) {
            const percentage = (energy / maxEnergy) * 100;
            return (
                <div className="energy-bar-container">
                    <div className="energy-bar-label">
                        <span>⚡️ Энергия</span>
                        <span>{Math.floor(energy)} / {maxEnergy}</span>
                    </div>
                    <div className="energy-bar-fill">
                        <div 
                            className="energy-bar-inner" 
                            style={{ width: `${percentage}%` }}>
                        </div>
                    </div>
                </div>
            );
        }

        function TabBar({ activeTab, onTabClick }) {
            const tabs = [
                { id: 'forest', name: 'Лес', icon: 'images/icon_forest.png' },
                { id: 'boosts', name: 'Бусты', icon: 'images/icon_boosts.png' },
                { id: 'raid',   name: 'Набег', icon: 'images/icon_raid.png' },
                { id: 'home',   name: 'Дупло', icon: 'images/icon_home.png' },
                { id: 'squad',  name: 'Стая', icon: 'images/icon_friends.png' }
            ];

            return (
                <nav className="tab-bar">
                    {tabs.map(tab => (
                        <div 
                            key={tab.id}
                            className={`tab-item ${activeTab === tab.id ? 'active' : ''}`}
                            onClick={() => onTabClick(tab.id)}
                        >
                            <img src={tab.icon} alt={tab.id} />
                            <span>{tab.name}</span>
                        </div>
                    ))}
                </nav>
            );
        }

        // --- Экраны ---
        
        function ForestScreen({ onTasksClick, completedTasks, onDailyRewardClick, isDailyRewardAvailable, onSettingsClick }) {
            
            // ФУНКЦИЯ ДЛЯ ОБРАБОТКИ ОТСУТСТВИЯ ИЗОБРАЖЕНИЯ (FOLBACK)
            const handleImageError = (e, fallbackEmoji) => {
                e.currentTarget.style.display = 'none'; 
                const span = document.createElement('span');
                span.textContent = fallbackEmoji;
                span.style.fontSize = '2.5em';
                span.style.color = 'white';
                span.style.textShadow = '0 0 5px black';
                e.currentTarget.parentNode.insertBefore(span, e.currentTarget);
            };

            return (
                <div className="forest-screen">
                    <button className="squirrel-btn">
                        <img src="images/squirrel_main_anim.png" alt="Tap me!" />
                    </button>
                    
                    {/* КНОПКА ЕЖЕДНЕВНЫХ НАГРАД (С фолбэком 🎁) */}
                    <button className="daily-rewards-button" onClick={onDailyRewardClick}>
                        <img 
                           src="images/icon_daily_rewards.png" 
                           alt="Daily Rewards" 
                           style={{width: '65px', height: '65px', flexShrink: 0}} 
                           onError={(e) => handleImageError(e, '🎁')}
                        />
                        {isDailyRewardAvailable && (
                            <div className="notification-badge">!</div>
                        )}
                    </button>
                    
                    {/* КНОПКА ЗАДАНИЙ (С фолбэком 📋) */}
                    <button className="tasks-button" onClick={onTasksClick}>
                        <img 
                           src="images/icon_tasks.png" 
                           alt="Задания" 
                           style={{width: '65px', height: '65px', flexShrink: 0}} 
                           onError={(e) => handleImageError(e, '📋')}
                        />
                        {completedTasks > 0 && (
                            <div className="notification-badge">{completedTasks}</div>
                        )}
                    </button>
                    
                    {/* КНОПКА НАСТРОЕК (С фолбэком ⚙️) - Уменьшенный размер */}
                    <button className="settings-button" onClick={onSettingsClick}>
                        <img 
                           src="images/icon_settings.png" 
                           alt="Настройки" 
                           style={{width: '55px', height: '55px', flexShrink: 0}} 
                           onError={(e) => handleImageError(e, '⚙️')}
                        />
                    </button>
                </div>
            );
        }

        function BoostsScreen({ 
            levels, balance, passiveRatePerSec, onBuy, 
            permBonusClick, permBonusLimit, permBonusRecharge 
        }) {
             return (
                <div className="upgrade-list">
                    <div className="boost-header">
                        <h2>🚀 Бусты (Атака и Фарм)</h2>
                    </div>
                    
                    {Object.values(BOOST_CATALOG).map(upgrade => {
                        const currentLevel = levels[upgrade.id];
                        const isMaxLevel = upgrade.type === 'level' && currentLevel >= upgrade.maxLevel;
                        
                        const cost = upgrade.type === 'once' 
                            ? upgrade.baseCost 
                            : calculateCost(upgrade.baseCost, currentLevel, upgrade.id);
                        
                        let descriptionLabel = ""; 
                        let currentValue = 0;
                        let nextValue = 0;
                        let valueSuffix = ""; 

                        if (upgrade.id === 'multitap') {
                            descriptionLabel = "Добыча:";
                            currentValue = (1 + levels.multitap * 1 + permBonusClick);
                            nextValue = (1 + (levels.multitap + 1) * 1 + permBonusClick);
                            valueSuffix = "$NUT/тап";
                        } else if (upgrade.id === 'energyLimit') {
                            descriptionLabel = "Лимит:";
                            currentValue = BASE_ENERGY + levels.energyLimit * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
                            nextValue = currentValue + ENERGY_LIMIT_PER_LEVEL;
                            valueSuffix = "⚡️";
                        } else if (upgrade.id === 'energyRecharge') {
                            descriptionLabel = "Реген:";
                            currentValue = (1 + levels.energyRecharge * ENERGY_RECHARGE_PER_LEVEL) + permBonusRecharge;
                            nextValue = currentValue + ENERGY_RECHARGE_PER_LEVEL;
                            valueSuffix = "⚡️/сек";
                        } else if (upgrade.id === 'autoBot') {
                             // ===>>> ИЗМЕНЕНИЕ 3: Обновление текста Белки-Робота <<<===
                             descriptionLabel = currentLevel > 0 
                                ? `Активен. Доход: +${passiveRatePerSec}/сек.`
                                : `Доход: +${BASE_BOT_RATE} $NUT/сек. В оффлайне работает не более 2ч.`;
                        }
                        
                        return (
                            <UpgradeItem 
                                key={upgrade.id}
                                upgrade={upgrade} 
                                level={currentLevel}
                                cost={cost}
                                canAfford={balance >= cost}
                                onBuy={() => onBuy(upgrade.id)}
                                isMaxLevel={isMaxLevel}
                                descriptionLabel={descriptionLabel}
                                currentValue={currentValue}
                                nextValue={nextValue}
                                valueSuffix={valueSuffix}
                            />
                        );
                    })}
                </div>
            );
        }


        function HomeScreen({ levels, balance, vaultBalance, vaultCapacity, myBaseHp, onBuy, onVaultAction }) {
            return null;
        }
        
        function RaidWrapper({ /* ... */ }) {
            return null;
        }

        function RaidSearchScreen({ /* ... */ }) {
            return null;
        }
        
        function RaidBattleScreen({ /* ... */ }) {
            return null;
        }


        function SquadScreen({ friendsList, nutBonus, onCollectBonus }) {
            return null;
        }
        
        function TasksModal({ 
            onClose, totalTaps, balance, totalEarned, taskLevels, onClaim, 
            completedTapTasks, completedBalanceTasks, completedMilestoneTasks 
        }) {
            
            const [activeTaskTab, setActiveTaskTab] = useState('tap');
            
            const [infoTaskId, setInfoTaskId] = useState(null); 
            
            const tapTaskLevel = taskLevels.tap_chain;
            const tapTask = TASK_CATALOG.tap_chain[taskLevels.tap_chain];
            
            const balanceTaskLevel = taskLevels.balance_chain;
            const balanceTask = TASK_CATALOG.balance_chain[taskLevels.balance_chain];
            
            const earnedTaskLevel = taskLevels.total_earned_chain;
            const earnedTask = TASK_CATALOG.total_earned_chain[taskLevels.total_earned_chain];
            
            const infoTask = infoTaskId 
                ? (TASK_CATALOG.tap_chain.find(t => t.id === infoTaskId) || 
                   TASK_CATALOG.balance_chain.find(t => t.id === infoTaskId) ||
                   TASK_CATALOG.total_earned_chain.find(t => t.id === infoTaskId)) 
                : null;
                
            const renderTabContent = () => {
                switch(activeTaskTab) {
                    case 'tap':
                        return tapTask ? (
                            <TaskItem 
                                task={tapTask} 
                                currentProgress={totalTaps} 
                                onClaim={() => onClaim('tap_chain')} 
                                onShowInfo={() => setInfoTaskId(tapTask.id)} 
                            />
                        ) : (
                            <p>Все задания по тапам выполнены!</p>
                        );
                    case 'balance':
                         return balanceTask ? (
                            <TaskItem 
                                task={balanceTask} 
                                currentProgress={balance} 
                                onClaim={() => onClaim('balance_chain')} 
                                onShowInfo={() => setInfoTaskId(balanceTask.id)} 
                            />
                        ) : (
                            <p>Все задания на баланс выполнены!</p>
                        );
                    case 'milestone':
                        return earnedTask ? (
                            <TaskItem 
                                task={earnedTask} 
                                currentProgress={totalEarned} 
                                onClaim={() => onClaim('total_earned_chain')} 
                                onShowInfo={() => setInfoTaskId(earnedTask.id)} 
                            />
                        ) : (
                            <p>Все вехи достигнуты!</p>
                        );
                    default:
                        return null;
                }
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="tasks-modal" onClick={(e) => e.stopPropagation()}>
                        
                        {infoTask ? (
                            <div>
                                <div className="icon level-icon" style={{fontSize: '3em', marginBottom: '15px'}}>{infoTask.icon}</div>
                                <h3 className="max-level">{infoTask.name}</h3>
                                <p style={{fontSize: '1.1em', color: '#eee', lineHeight: 1.4, marginBottom: '20px'}}>
                                    {infoTask.details}
                                </p>
                                <button className="buy-btn" style={{backgroundColor: '#007BFF'}} onClick={() => setInfoTaskId(null)}>
                                    Назад
                                </button>
                            </div>
                        ) : (
                            <div>
                                <h2>Задания</h2>
                                
                                <div className="task-tab-bar">
                                    <div 
                                        className={`task-tab ${activeTaskTab === 'tap' ? 'active' : ''}`}
                                        onClick={() => setActiveTaskTab('tap')}
                                    >
                                        Начало
                                        {completedTapTasks > 0 && (
                                            <span className="task-tab-badge">{completedTapTasks}</span>
                                        )}
                                    </div>
                                    <div 
                                        className={`task-tab ${activeTaskTab === 'balance' ? 'active' : ''}`}
                                        onClick={() => setActiveTaskTab('balance')}
                                    >
                                        Сбережения
                                        {completedBalanceTasks > 0 && (
                                            <span className="task-tab-badge">{completedBalanceTasks}</span>
                                        )}
                                    </div>
                                    <div 
                                        className={`task-tab ${activeTaskTab === 'milestone' ? 'active' : ''}`}
                                        onClick={() => setActiveTaskTab('milestone')}
                                    >
                                        Прогресс
                                        {completedMilestoneTasks > 0 && (
                                            <span className="task-tab-badge">{completedMilestoneTasks}</span>
                                        )}
                                    </div>
                                </div>
                                
                                <div className="task-list-content">
                                    {renderTabContent()}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }
        
        function TaskItem({ task, currentProgress, onClaim, onShowInfo }) { 
            const isComplete = currentProgress >= task.target;
            const progressPercent = Math.min(100, (currentProgress / task.target) * 100);
            
            let rewardText = '...';
            if (task.type === 'tap') rewardText = `+${task.reward} $NUT`;
            if (task.type === 'balance') rewardText = 'x2';
            if (task.type === 'milestone') rewardText = getMilestoneRewardText(task.reward);

            return (
                <div className={`task-item ${isComplete ? 'is-claimable' : ''}`}>
                    <div className="icon">{task.icon}</div>
                    <div className="task-info">
                        <div className="task-title-row"> 
                            <strong>{task.name}</strong>
                            <button className="task-info-btn" onClick={onShowInfo}>i</button>
                        </div>
                        <div className="progress-text">{`Прогресс: ${formatBalance(currentProgress)} / ${formatBalance(task.target)}`}</div>
                        <div className="progress-bar">
                            <div className="progress-bar-inner" style={{ width: `${progressPercent}%` }}></div>
                        </div>
                    </div>
                    <button 
                        className="buy-btn" 
                        disabled={!isComplete} 
                        onClick={onClaim}
                        style={{marginLeft: '10px'}}
                    >
                        {rewardText}
                    </button>
                </div>
            );
        }


        // ===>>> ИЗМЕНЕНИЕ 3: ЛОГИКА UpgradeItem <<<===
        function UpgradeItem({ 
            upgrade, level, cost, canAfford, onBuy, isMaxLevel,
            descriptionLabel, currentValue, nextValue, valueSuffix 
        }) {
            const isPurchased = upgrade.type === 'once' && level > 0;
            
            let buttonText = 'Куплено';
            let buttonClass = 'purchased';
            let isDisabled = true;
            
            if (upgrade.type === 'level') {
                if (isMaxLevel) {
                     buttonText = 'МАКС.';
                     buttonClass = 'max-level'; 
                     isDisabled = true;
                } else {
                     buttonText = `Ур. ${level + 1} за ${cost.toLocaleString('ru-RU')} $NUT`;
                     buttonClass = '';
                     isDisabled = !canAfford;
                }
            } else if (upgrade.type === 'once' && !isPurchased) {
                buttonText = `${cost.toLocaleString('ru-RU')} $NUT`;
                buttonClass = '';
                isDisabled = !canAfford;
            }

            const formatValue = (val) => val.toFixed(1).replace(/\.0$/, '');

            return (
                <div className="upgrade-item">
                    <img src={upgrade.icon} alt={upgrade.name} />
                    
                    <div className="upgrade-info">
                        <strong style={{color: 'gold'}}>{upgrade.name}</strong>
                        
                        {upgrade.type === 'level' && (
                            <div className="level-text">
                                {isMaxLevel ? `Уровень: ${level} (MAX)` : `Уровень: ${level}`}
                            </div>
                        )}
                        
                        <div className="description-line">
                            
                            {upgrade.type === 'level' && !isMaxLevel && (
                                <span>
                                    {descriptionLabel}
                                    {` +${formatValue(currentValue)} ${valueSuffix}`}
                                    <span className="description-line-next">
                                        {` -> +${formatValue(nextValue)} ${valueSuffix}`}
                                    </span>
                                </span>
                            )}
                            
                            {upgrade.type === 'level' && isMaxLevel && (
                                <span>
                                  {descriptionLabel}
                                  {` +${formatValue(currentValue)} ${valueSuffix}`}
                                </span>
                            )}
                            
                            {upgrade.type === 'once' && (
                                <span>{descriptionLabel}</span>
                            )}
                        </div>
                    </div>
                    
                    <button 
                        className={`buy-btn ${buttonClass}`} 
                        disabled={isDisabled}
                        onClick={onBuy}
                    >
                        {buttonText}
                    </button>
                </div>
            );
        }
        
        
        // Старт Приложения
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>

</body>
</html>
